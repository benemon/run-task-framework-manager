package controller

import (
	"bytes"
	"encoding/json"
	"fmt"
	"{{.RunTaskName}}/internal/api"
	"log"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

// Status constants for the RunTaskResponse
const (
	Passed  = "passed"
	Failed  = "failed"
	Running = "running"
)

// TaskResults constant for the RunTaskResponse
const (
	TaskResults = "task-results"
)

// Terraform Cloud default test token
const (
	TestToken = "test-token"
)

// Create a buffered channel as an in-memory queue
var queue = make(chan api.RunTaskRequest, 100)

func worker() {
	for request := range queue {
		handleRequest(request)
	}
}

func handleRequest(request api.RunTaskRequest) {
	jsonRequest, jsonErr := json.MarshalIndent(request, "", "  ")
	if jsonErr != nil {
		log.Printf("Error formatting request: %v", jsonErr)
		return
	}

	if request.AccessToken != TestToken {

		/*
			Implement Run Task logic here
			processRequest(request)
			For now, just log the request and send the response
		*/
		log.Printf("Request: %s", jsonRequest)

		// Send a response back to the platform
		var response, err = buildResponse(Passed, "", "")
		if err != nil {
			response, _ = buildResponse(Failed, err.Error(), "")
		}
		sendResponse(response, request.TaskResultCallbackURL, request.AccessToken)
	}

}

/*
This is a placeholder function indication a possible location to the Run Task logic
func processRequest(request api.RunTaskRequest)  {
*/

func buildResponse(status string, message string, detailsUrl string) (*api.RunTaskResponse, error) {

	var response api.RunTaskResponse

	response.Data.Type = TaskResults
	response.Data.Attributes.Status = status

	if len(message) > 0 {
		response.Data.Attributes.Message = message
	}
	if len(detailsUrl) > 0 {
		response.Data.Attributes.URL = detailsUrl
	}

	jsonResponse, err := json.MarshalIndent(response, "", "  ")
	if err != nil {
		log.Printf("Error formatting response: %v", err)
		return nil, err
	}

	log.Printf("Response: %s", jsonResponse)

	return &response, nil
}

func sendResponse(response *api.RunTaskResponse, uri string, token string) {
	client := &http.Client{
		Timeout: time.Second * 10,
	}

	jsonResponse, jsonErr := json.Marshal(response)

	if jsonErr != nil {
		log.Print(jsonErr)
	}

	req, reqErr := http.NewRequest("PATCH", uri, bytes.NewBuffer(jsonResponse))

	if reqErr != nil {
		log.Print(reqErr)
	}

	req.Header.Set("Content-Type", "application/vnd.api+json")
	req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))

	responseResult, respErr := client.Do(req)

	if respErr != nil {
		log.Print(respErr.Error())
	}
	defer responseResult.Body.Close()
}

func RunTaskController() {
	router := gin.Default()

	router.POST("/api", func(c *gin.Context) {
		var request api.RunTaskRequest
		if err := c.ShouldBindJSON(&request); err != nil {
			c.Status(http.StatusBadRequest)
			return
		}

		// Add the request to the queue
		queue <- request

		c.Status(http.StatusOK)
	})

	// Start a fixed number of workers
	for i := 0; i < 10; i++ {
		go worker()
	}

	// Listen and serve on 0.0.0.0:8080
	router.Run(":8080")

	// Listen and serve on 0.0.0.0:8443
	//router.RunTLS(":8443", "/path/to/cert.pem", "/path/to/key.pem")
}
